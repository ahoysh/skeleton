'use strict';

const prompts = require('prompts');
const colors = require('colors');
const fs = require('fs');
const path = require('path');

const Validator = require('jsonschema').Validator;
const validate = new Validator();
const generator = require('generate-password');

const constants = require("./constants.js");

let config = require('rc')('ahoy', JSON.parse(fs.readFileSync(path.join(__dirname, "../config.json"))));


class Question {

  /**
   * @param {object} skeletonConfig - the skeleton configuration object
   *
   * @constructs
   */
	constructor(skeletonConfig) {
    this.autoGenerated = {}
		this.skeletonConfig = this._validateSkeletonConfig(skeletonConfig);
    this.questions = this._validateQuestions(this.skeletonConfig.questions);
	}

  /**
   * Validates the skeleton configuration file
   *
   * @param {object} skeletonConfig - the skeleton configuration object
   *
   * @private
   */
  _validateSkeletonConfig(skeletonConfig) {
    let schema;
    try {
      schema = fs.readFileSync(path.join(__dirname,  "../", config.schema) + '.json')
    } catch (err) {
      console.log(colors.red("Missing skeleton schema file"))
      return;
    }
    try {
      validate.addSchema(JSON.parse(schema), '/Skeleton');
    } catch (err) {
      console.log(colors.red("Malformed schema file"))
      return;
    }
    return skeletonConfig;
  }

  /**
   * Validates the skeleton questions
   *
   * @param {object} questions - the skeleton questions
   *
   * @private
   */
	_validateQuestions(questions) {
    // Find auto generated fields and generate them
    let autoGenerate = questions.filter(q => q.type === 'auto' && constants.RESERVED_FIELD_NAMES.indexOf(q.name) === -1)
    for (const q of autoGenerate) {
      this.autoGenerated[q.name] = generator.generate({
        length: q.length || 10,
        uppercase: q.uppercase || true,
        lowercase: q.lowercase || true,
        numbers: q.numbers || true,
        symbols: q.symbols || false,
        exclude: "\'\"\`"
      })
    }
    // Filter out auto generated fields
    questions = questions.filter(q => q.type !== 'auto' && constants.RESERVED_FIELD_NAMES.indexOf(q.name) === -1)
    for (const q of questions) {
      if (q.hasOwnProperty('widget') == true && Object.keys(constants.WIDGETS).includes(q.widget))
        q.type = constants.WIDGETS[q.widget];
      if (Object.keys(constants.VALIDATION).includes(q.type))
        q.validate = constants.VALIDATION[q.type];
      if (Object.keys(constants.MASK).includes(q.type) && q.hasOwnProperty('mask') == false)
        q.mask = constants.MASK[q.type];
      q.type = constants.QUESTION_TYPE[q.type];
    }
    return [...constants.DEFAULT_QUESTIONS, ...questions];
	}

  /**
   * Prompts the user for input used to generate a project from skeleton template
   */
  async questionPromptSync() {
    let anwsers
    try {
      anwsers = await prompts(this.questions);
      return {...anwsers, ...this.autoGenerated};
    } catch(error) {
      console.log(colors.red(error));
      process.exit(1)
    }
  }

}

module.exports = Question;